// Top_Problema2_Minimo.sv
module Top_Problema2_Minimo #(
    parameter int WIDTH = 4
)(
    input  logic       CLOCK_50,     // reloj placa
    input  logic [9:0] SW,           // A=SW[3:0], B=SW[7:4], OP=SW[9:8] + SW[?] (ver abajo)
    input  logic [3:0] KEY,          // KEY[1]=RESET (activa en bajo)
    output logic [9:0] LEDR          // para ver salida registrada
);
    // Reset activo en bajo (usa KEY[1])
    logic rst_n = KEY[1];

    // Entradas a la ALU desde switches:
    // - Para WIDTH=4: A=SW[3:0], B=SW[7:4]
    // - Opcode: ponlo con SW[9:6] (4 bits)
    logic [WIDTH-1:0] A_sw, B_sw;
    logic [3:0]       OP_sw;

    assign A_sw = SW[3:0];
    assign B_sw = SW[7:4];
    assign OP_sw = {SW[9], SW[8], SW[6], SW[5]}; // 4 bits cualquiera; ajusta a gusto

    // Núcleo FF–ALU–FF
    logic [WIDTH-1:0] result_q;

    CriticalPathHarness #(.WIDTH(WIDTH)) u_harness (
        .clk   (CLOCK_50),
        .rst_n (rst_n),
        .din_a (A_sw),
        .din_b (B_sw),
        .din_op(OP_sw),
        .dout_q(result_q)
    );

    // Mostrar algo sin tocar la ruta: LEDs con la salida registrada
    always_comb begin
        LEDR        = '0;
        LEDR[WIDTH-1:0] = result_q; // p.ej. 4 LEDs bajos
    end
endmodule
